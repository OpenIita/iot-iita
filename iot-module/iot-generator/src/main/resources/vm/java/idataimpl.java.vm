package ${packageName}.data;

import cc.iotkit.data.ICommonData;
import ${packageName}.data.I${ClassName}Data;
import ${packageName}.data.model.Tb${ClassName};
import ${packageName}.model.${ClassName};
import java.util.List;
import com.querydsl.core.QueryResults;
import com.querydsl.core.types.Predicate;
import com.querydsl.core.types.Projections;
import com.querydsl.jpa.impl.JPAQueryFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import cc.iotkit.data.util.PredicateBuilder;

import cc.iotkit.common.api.PageRequest;
import cc.iotkit.common.api.Paging;
import cc.iotkit.common.utils.StringUtils;
import java.util.Collection;
import cc.iotkit.common.utils.MapstructUtils;


import static ${packageName}.data.model.QTb${ClassName}.tb${ClassName};
/**
 * 数据实现接口
 *
 * @author ${author}
 * @date ${datetime}
 */
@Primary
@Service
@RequiredArgsConstructor
public class ${ClassName}DataImpl implements I${ClassName}Data {

    private final ${ClassName}Repository baseRepository;

    private final JPAQueryFactory jpaQueryFactory;

    @Override
    public Paging<${ClassName}> findAll(PageRequest<${ClassName}> pageRequest) {
        return PageBuilder.toPaging(baseRepository.findAll(buildQueryCondition(pageRequest.getData()), PageBuilder.toPageable(pageRequest))).to(${ClassName}.class);
    }

    private Predicate buildQueryCondition(${ClassName} bo) {
        PredicateBuilder builder = PredicateBuilder.instance();

        #foreach($column in $columns)
            #if($column.query)
                #set($queryType=$column.queryType)
                #set($javaField=$column.javaField)
                #set($javaType=$column.javaType)
                #set($columnName=$column.columnName)
                #set($AttrName=$column.javaField.substring(0,1).toUpperCase() + ${column.javaField.substring(1)})
                #if($queryType != 'BETWEEN')
                    #if($javaType == 'String')
                        #set($condition='StringUtils.isNotBlank(bo.get'+$AttrName+'())')
                    #else
                        #set($condition='bo.get'+$AttrName+'() != null')
                    #end
                    builder.and($condition, ()=>tb${ClassName}.${javaField}.eq(bo.get${AttrName}()));
                #else
                    builder.and(params.get("begin$AttrName") != null && params.get("end$AttrName") != null,
                            ()=>tb${ClassName}.${javaField}.bettwen(params.get("begin$AttrName"), params.get("end$AttrName")));
                #end
            #end
        #end
        return builder.build();
    }

    @Override
    public List<${ClassName}> findByIds(Collection<Long> id) {
        List allById = baseRepository.findAllById(id);
        return MapstructUtils.convert(allById, ${ClassName}.class);
    }

    @Override
    public ${ClassName} save(${ClassName} data) {
        Object o = baseRepository.save(MapstructUtils.convert(data, Tb${ClassName}.class));
        return MapstructUtils.convert(o, ${ClassName}.class);
    }

    @Override
    public void batchSave(List<${ClassName}> data) {
        baseRepository.saveAll(MapstructUtils.convert(data, Tb${ClassName}.class));
    }

    @Override
    public void deleteById(Long id) {
        baseRepository.deleteById(id);
    }

    @Override
    public void deleteByIds(Collection<Long> ids) {
        baseRepository.deleteAllById(ids);
    }

    @Override
    public ${ClassName} findById(Long id) {
        Tb${ClassName} ret = jpaQueryFactory.select(tb${ClassName}).from(tb${ClassName}).where(tb${ClassName}.id.eq(id)).fetchOne();
        ${ClassName} convert = MapstructUtils.convert(ret, ${ClassName}.class);
        return convert;
    }
}
